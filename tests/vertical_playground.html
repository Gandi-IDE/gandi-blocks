<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico" />
    <title>Vertical Playground</title>
    <style>
      :root {
        --theme-color-700: #d7dde4;
        --theme-color-600: #16191f;
        --theme-color-550: #f5f6fa;
        --theme-color-500: #edeff2;
        --theme-color-400: #ffffff;
        --theme-color-350: #dbdbdb;
        --theme-color-300: #fcfcfc;
        --theme-color-200: #e8eaed;
        --theme-color-100: #d2d4d7;
        --theme-color-100-op03: rgba(210, 212, 231, 0.3);
        --theme-color-50: rgba(156, 163, 175, 0.16);
        --theme-color-b100: #1c6bd9;
        --theme-color-b200: #b5d6ff;
        --theme-color-g500: #9ca3af;
        --theme-color-g400: #828997;
        --theme-color-g300: #6b7280;
        --theme-color-yellow: 208, 165, 13;
        --theme-text-primary: #262b33;
        --theme-border-size-tip: 0px;
        --theme-border-color-tip: transparent;
        --theme-scrollbar-color: rgba(36, 39, 49, 0.3);
        --theme-box-shadow-color: rgba(0, 0, 0, 0.12);
        --theme-brand-color: #2d8cff;
        --theme-error-color: #fa594c;
        --theme-brand-color-p3: rgba(45, 140, 255, 0.3);
        --theme-error-color-p3: rgba(250, 89, 76, 0.3);
      }
    </style>

    <script src="../blockly_uncompressed_vertical.js"></script>
    <script src="../msg/messages.js"></script>
    <script src="../msg/scratch_msgs.js"></script>
    <script src="../blocks_vertical/vertical_extensions.js"></script>
    <script src="../blocks_common/math.js"></script>
    <script src="../blocks_common/matrix.js"></script>
    <script src="../blocks_common/note.js"></script>
    <script src="../blocks_common/text.js"></script>
    <script src="../blocks_common/colour.js"></script>
    <script src="../blocks_vertical/control.js"></script>
    <script src="../blocks_vertical/event.js"></script>
    <script src="../blocks_vertical/motion.js"></script>
    <script src="../blocks_vertical/looks.js"></script>
    <script src="../blocks_vertical/procedures.js"></script>
    <script src="../blocks_vertical/operators.js"></script>
    <script src="../blocks_vertical/sound.js"></script>
    <script src="../blocks_vertical/sensing.js"></script>
    <script src="../blocks_vertical/data.js"></script>
    <script src="../blocks_vertical/extensions.js"></script>
    <script src="../blocks_vertical/default_toolbox.js"></script>

    <script>
      "use strict";
      var workspace = null;
      Blockly.showDropdownSearchableDataType = true;
      Blockly.showDropdownSearchableDropdowns = true;
      function start() {
        var soundsEnabled = null;
        if (sessionStorage) {
          // Restore sounds state.
          soundsEnabled = sessionStorage.getItem("soundsEnabled");
          if (soundsEnabled === null) {
            soundsEnabled = true;
          } else {
            soundsEnabled = soundsEnabled === "true";
          }
        } else {
          soundsEnabled = true;
        }
        setSoundsEnabled(soundsEnabled);

        // Setup blocks
        // Parse the URL arguments.
        var match = location.search.match(/dir=([^&]+)/);
        var rtl = match && match[1] == "rtl";
        document.forms.options.elements.dir.selectedIndex = Number(rtl);
        var toolbox = getToolboxElement();
        document.forms.options.elements.toolbox.selectedIndex = toolbox ? 1 : 0;

        match = location.search.match(/side=([^&]+)/);

        var side = match ? match[1] : "start";

        document.forms.options.elements.side.value = side;

        match = location.search.match(/locale=([^&]+)/);
        var locale = match ? match[1] : "en";
        Blockly.ScratchMsgs.setLocale(locale);
        document.forms.options.elements.locale.value = locale;

        // Create main workspace.
        workspace = Blockly.inject("blocklyDiv", {
          comments: true,
          frames: true,
          disable: false,
          collapse: false,
          media: "../media/",
          readOnly: false,
          rtl: rtl,
          scrollbars: true,
          toolbox: toolbox,
          toolboxPosition: side == "top" || side == "start" ? "start" : "end",
          horizontalLayout: side == "top" || side == "bottom",
          sounds: soundsEnabled,
          zoom: {
            controls: true,
            wheel: true,
            startScale: 0.675,
            maxScale: 4,
            minScale: 0.25,
            scaleSpeed: 1.1,
          },
          colours: {
            fieldShadow: "rgba(255, 255, 255, 0.3)",
            dragShadowOpacity: 0.6,
          },
        });

        if (sessionStorage) {
          // Restore previously displayed text.
          var text = sessionStorage.getItem("textarea");
          if (text) {
            document.getElementById("importExport").value = text;
          }
          taChange();
        }

        if (sessionStorage) {
          // Restore event logging state.
          var state = sessionStorage.getItem("logEvents");
          logEvents(Boolean(state));

          // Restore flyout event logging state.
          state = sessionStorage.getItem("logFlyoutEvents");
          logFlyoutEvents(Boolean(state));
        }
      }

      function getToolboxElement() {
        var match = location.search.match(/toolbox=([^&]+)/);
        return document.getElementById(
          "toolbox-" + (match ? match[1] : "categories")
        );
      }

      function toXml() {
        var output = document.getElementById("importExport");
        var xml = Blockly.Xml.workspaceToDom(workspace);
        output.value = Blockly.Xml.domToPrettyText(xml);
        output.focus();
        output.select();
        taChange();
      }

      function fromXml() {
        var input = document.getElementById("importExport");
        var xml = Blockly.Xml.textToDom(input.value);
        Blockly.Xml.domToWorkspace(xml, workspace);
        taChange();
      }

      // Disable the "Import from XML" button if the XML is invalid.
      // Preserve text between page reloads.
      function taChange() {
        var textarea = document.getElementById("importExport");
        if (sessionStorage) {
          sessionStorage.setItem("textarea", textarea.value);
        }
        var valid = true;
        try {
          Blockly.Xml.textToDom(textarea.value);
        } catch (e) {
          valid = false;
        }
        document.getElementById("import").disabled = !valid;
      }

      function logEvents(state) {
        var checkbox = document.getElementById("logCheck");
        checkbox.checked = state;
        if (sessionStorage) {
          sessionStorage.setItem("logEvents", state ? "checked" : "");
        }
        if (state) {
          workspace.addChangeListener(logger);
        } else {
          workspace.removeChangeListener(logger);
        }
      }

      function logFlyoutEvents(state) {
        var checkbox = document.getElementById("logFlyoutCheck");
        checkbox.checked = state;
        var soundsEnabled = null;
        if (sessionStorage) {
          sessionStorage.setItem("logFlyoutEvents", state ? "checked" : "");
        }
        var flyoutWorkspace = workspace.flyout_
          ? workspace.flyout_.workspace_
          : workspace.toolbox_.flyout_.workspace_;
        if (state) {
          flyoutWorkspace.addChangeListener(logger);
        } else {
          flyoutWorkspace.removeChangeListener(logger);
        }
      }

      function logger(e) {
        console.log(e);
      }

      function glowBlock() {
        if (Blockly.selected) {
          workspace.glowBlock(Blockly.selected.id, true);
        }
      }

      function unglowBlock() {
        if (Blockly.selected) {
          workspace.glowBlock(Blockly.selected.id, false);
        }
      }

      function glowStack() {
        if (Blockly.selected) {
          workspace.glowStack(Blockly.selected.id, true);
        }
      }

      function unglowStack() {
        if (Blockly.selected) {
          workspace.glowStack(Blockly.selected.id, false);
        }
      }

      function sprinkles(n) {
        var prototypes = [];
        var toolbox = workspace.options.languageTree;
        if (!toolbox) {
          console.error("Toolbox not found; add a toolbox element to the DOM.");
          return;
        }
        var blocks = toolbox.getElementsByTagName("block");
        for (var i = 0; i < n; i++) {
          var blockXML = blocks[Math.floor(Math.random() * blocks.length)];
          var block = Blockly.Xml.domToBlock(blockXML, workspace);
          block.initSvg();
          block.moveBy(
            Math.round(Math.random() * 450 + 40),
            Math.round(Math.random() * 600 + 40)
          );
        }
      }

      var equalsXml = [
        '  <shadow type="operator_equals">',
        '    <value name="OPERAND1">',
        '     <shadow type="text">',
        '      <field name="TEXT">foo</field>',
        "     </shadow>",
        "    </value>",
        '    <value name="OPERAND2">',
        '      <shadow type="operator_equals"></shadow>',
        "    </value>",
        "  </shadow>",
      ].join("\n");

      var spaghettiXml = [
        '  <block type="control_if_else">',
        '    <value name="CONDITION">',
        '      <shadow type="operator_equals"></shadow>',
        "    </value>",
        '    <statement name="SUBSTACK"></statement>',
        '    <statement name="SUBSTACK2"></statement>',
        "    <next></next>",
        "  </block>",
      ].join("\n");

      function spaghetti(n) {
        console.log("Starting spaghetti.  This may take some time...");
        var xml = spaghettiXml;
        // Nest if/else statements deeply.
        for (var i = 0; i < 2 * n; i++) {
          xml = xml.replace(
            /(<statement name="SUBSTACK2?"?>)<\//g,
            "$1" + spaghettiXml + "</"
          );
        }
        // Stack a bit.
        for (var i = 0; i < n; i++) {
          xml = xml.replace(/(<next>)<\//g, "$1" + spaghettiXml + "</");
        }

        // Nest boolean comparisons.
        var equalsBlock = equalsXml;
        for (var i = 0; i < n; i++) {
          equalsBlock = equalsBlock.replace(
            /(<shadow( type="operator_equals")?>)<\/shadow>/g,
            equalsXml
          );
        }

        // Put the nested boolean comparisons into if/else statements.
        xml = xml.replace(
          /(<shadow( type="operator_equals")?>)<\/shadow>/g,
          equalsBlock
        );

        xml = '<xml xmlns="http://www.w3.org/1999/xhtml">' + xml + "</xml>";
        var dom = Blockly.Xml.textToDom(xml);
        console.time("Spaghetti domToWorkspace");
        Blockly.Xml.domToWorkspace(dom, workspace);
        console.timeEnd("Spaghetti domToWorkspace");
      }

      function setSoundsEnabled(state) {
        var checkbox = document.getElementById("soundsEnabled");
        checkbox.checked = state ? "checked" : "";
        if (sessionStorage) {
          sessionStorage.setItem("soundsEnabled", state);
        }
      }

      function reportDemo() {
        if (Blockly.selected) {
          workspace.reportValue(
            Blockly.selected.id,
            document.getElementById("reportValue").value
          );
        }
      }

      function setLocale(locale) {
        workspace.getFlyout().setRecyclingEnabled(false);
        var xml = Blockly.Xml.workspaceToDom(workspace);
        Blockly.ScratchMsgs.setLocale(locale);
        Blockly.Xml.clearWorkspaceAndLoadFromXml(xml, workspace);
        workspace.getFlyout().setRecyclingEnabled(true);
      }

      function setPosition() {
        workspace.centerOnFirstComment();
      }
    </script>

    <style>
      html,
      body {
        height: 100%;
      }

      body {
        background-color: #fff;
        font-family: sans-serif;
        overflow: hidden;
      }

      h1 {
        font-weight: normal;
        font-size: 140%;
      }

      #blocklyDiv {
        float: right;
        height: 95%;
        width: 70%;
      }

      #collaborators {
        float: right;
        width: 30px;
        margin-left: 10px;
      }

      #collaborators > img {
        margin-right: 5px;
        height: 30px;
        padding-bottom: 5px;
        width: 30px;
        border-radius: 3px;
      }

      #importExport {
        font-family: monospace;
      }
    </style>
  </head>

  <body onload="start()">
    <div id="collaborators"></div>
    <div id="blocklyDiv"></div>
    <!-- Simple toolbox -->
    <xml id="toolbox-simple" style="display: none">
      <block type="operator_random">
        <value name="FROM">
          <shadow type="math_number">
            <field name="NUM">1</field>
          </shadow>
        </value>
        <value name="TO">
          <shadow type="math_number">
            <field name="NUM">10</field>
          </shadow>
        </value>
      </block>
      <block type="operator_lt">
        <value name="OPERAND1">
          <shadow type="text">
            <field name="TEXT"></field>
          </shadow>
        </value>
        <value name="OPERAND2">
          <shadow type="text">
            <field name="TEXT"></field>
          </shadow>
        </value>
      </block>
      <block type="operator_equals">
        <value name="OPERAND1">
          <shadow type="text">
            <field name="TEXT"></field>
          </shadow>
        </value>
        <value name="OPERAND2">
          <shadow type="text">
            <field name="TEXT"></field>
          </shadow>
        </value>
      </block>
      <block type="operator_gt">
        <value name="OPERAND1">
          <shadow type="text">
            <field name="TEXT"></field>
          </shadow>
        </value>
        <value name="OPERAND2">
          <shadow type="text">
            <field name="TEXT"></field>
          </shadow>
        </value>
      </block>
      <block type="operator_and"></block>
      <block type="operator_or"></block>
      <block type="operator_not"></block>
      <block type="operator_join">
        <value name="STRING1">
          <shadow type="text">
            <field name="TEXT">hello</field>
          </shadow>
        </value>
        <value name="STRING2">
          <shadow type="text">
            <field name="TEXT">world</field>
          </shadow>
        </value>
      </block>
      <block type="operator_letter_of">
        <value name="LETTER">
          <shadow type="math_whole_number">
            <field name="NUM">1</field>
          </shadow>
        </value>
        <value name="STRING">
          <shadow type="text">
            <field name="TEXT">world</field>
          </shadow>
        </value>
      </block>
      <block type="operator_length">
        <value name="STRING">
          <shadow type="text">
            <field name="TEXT">world</field>
          </shadow>
        </value>
      </block>
      <block type="operator_mod">
        <value name="NUM1">
          <shadow type="math_number">
            <field name="NUM"></field>
          </shadow>
        </value>
        <value name="NUM2">
          <shadow type="math_number">
            <field name="NUM"></field>
          </shadow>
        </value>
      </block>
      <block type="operator_round">
        <value name="NUM">
          <shadow type="math_number">
            <field name="NUM"></field>
          </shadow>
        </value>
      </block>
      <block type="operator_mathop">
        <value name="OPERATOR">
          <shadow type="operator_mathop_menu"></shadow>
        </value>
        <value name="NUM">
          <shadow type="math_number">
            <field name="NUM"></field>
          </shadow>
        </value>
      </block>
    </xml>

    <!-- Sidebar -->
    <h1>Vertical Blocks</h1>
    <p>
      <a href="javascript:void(workspace.setVisible(true))">Show</a>
      - <a href="javascript:void(workspace.setVisible(false))">Hide</a>
    </p>

    <form id="options">
      <select name="dir" onchange="document.forms.options.submit()">
        <option value="ltr">LTR</option>
        <option value="rtl">RTL</option>
      </select>
      <select name="toolbox" onchange="document.forms.options.submit()">
        <option value="categories">Categories</option>
        <option value="simple">Simple</option>
      </select>
      <select name="side" onchange="document.forms.options.submit()">
        <option value="start">Start</option>
        <option value="end">End</option>
        <option value="top">Top</option>
        <option value="bottom">Bottom</option>
      </select>
      <select name="locale" onchange="setLocale(this.value)">
        <option value="en">English</option>
        <option value="ca">Catalan</option>
        <option value="cs">Czech</option>
        <option value="da">Danish</option>
        <option value="nl">Dutch</option>
        <option value="fi">Finnish</option>
        <option value="fr">French</option>
        <option value="de">German</option>
        <option value="el">Greek</option>
        <option value="he">Hebrew</option>
        <option value="hu">Hungarian</option>
        <option value="id">Indonesian</option>
        <option value="ga">Irish Gaelic</option>
        <option value="it">Italian</option>
        <option value="ja">Japanese</option>
        <option value="ja-Hira">Japanese(Hira)</option>
        <option value="mi">Maori</option>
        <option value="nb">Norwegian (Bokmal)</option>
        <option value="pt">Portuguese</option>
        <option value="pt-br">Portuguese (Brazil)</option>
        <option value="gd">Scottish Gaelic</option>
        <option value="sr">Serbian</option>
        <option value="sl">Slovenian</option>
        <option value="es">Spanish</option>
        <option value="es-419">Spanish (Latin America)</option>
        <option value="sv">Swedish</option>
        <option value="tr">Turkish</option>
        <option value="uk">Ukranian</option>
        <option value="vi">Vietnamese</option>
        <option value="cy">Welsh</option>
        <option value="zh-cn">Chinese (China)</option>
        <option value="zh-tw">Chinese (TW)</option>
      </select>
    </form>

    <p>
      <input type="button" value="Export to XML" onclick="toXml()" />
      &nbsp;
      <input
        type="button"
        value="Import from XML"
        onclick="fromXml()"
        id="import"
      />
      <br />
      <textarea
        id="importExport"
        style="width: 26%; height: 12em"
        onchange="taChange();"
        onkeyup="taChange()"
      ></textarea>
    </p>

    <hr />

    <p>
      Log events: &nbsp;
      <input type="checkbox" onclick="logEvents(this.checked)" id="logCheck" />
    </p>

    <p>
      Stress test: &nbsp;
      <input type="button" value="Sprinkles!" onclick="sprinkles(100)" />
      <input type="button" value="Spaghetti!" onclick="spaghetti(3)" />
    </p>

    <p>
      Glows: &nbsp;
      <input
        type="button"
        value="Glow last clicked block"
        onclick="glowBlock()"
      />
      <input
        type="button"
        value="Unglow last clicked block"
        onclick="unglowBlock()"
      />
      <input
        type="button"
        value="Stack glow last clicked block"
        onclick="glowStack()"
      />
      <input
        type="button"
        value="Stack unglow last clicked block"
        onclick="unglowStack()"
      />
    </p>

    <p>
      Log flyout events: &nbsp;
      <input
        type="checkbox"
        onclick="logFlyoutEvents(this.checked)"
        id="logFlyoutCheck"
      />
    </p>

    <p>
      Enable sounds (after refresh): &nbsp;
      <input
        type="checkbox"
        onclick="setSoundsEnabled(this.checked)"
        id="soundsEnabled"
      />
    </p>

    <p>
      <input type="button" value="Undo" onclick="workspace.undo()" />
      <input type="button" value="Redo" onclick="workspace.undo(true)" />
    </p>

    <p>
      Report:
      <input id="reportValue" type="text" value="123" />
      <input
        type="button"
        value="Report last clicked block"
        onclick="reportDemo()"
      />
    </p>
    <button onclick="setPosition()">定位</button>
    <script>
        function test() {
          // 测试插入积木到SUBSTACK
          // setTimeout(() => {
          //   moveBlockTo("@;uQ;H1}I}c=uX-UeACk", {x: 319.5925925925926, y: 514.6296296296297});
          //   connectBothBlock("KpBb]rQq=5:kNkeHGg9Z", ".ROZy2^d%1.?Lwm::Uww")
          //   connectBothBlock("@;uQ;H1}I}c=uX-UeACk", "$WU~9bDav5NhnLs{TmEh", "SUBSTACK")
          // }, 3000)

          // 测试插入积木到SUBSTACK
          // setTimeout(() => {
          //   moveBlockTo("*D?Cy7pOv{hZD4QR-{--", {x: 76, y: 1151});
          //   connectBothBlock("!e*UF_|SNZ8*XV9afgUz", "*D?Cy7pOv{hZD4QR-{--")
          //   connectBothBlock("*D?Cy7pOv{hZD4QR-{--", "AmBgpdKG@V$_vsO=.?P$", "SUBSTACK")
          // }, 3000)

          // setTimeout(() => {
            // disconnectBothBlock('Q9:51[,(,oeGvT%DefNy', {x: 10, y: 90})
            // moveBlockTo("Q9:51[,(,oeGvT%DefNy", {x: 379, y: -15})
            // disconnectBothBlock('GR}B9jJ-dIdSWg%BhdN+', {x: 379, y: 81})
            // connectBothBlock('GR}B9jJ-dIdSWg%BhdN+', '/a:b{sNh}9GmV7xGToX%')
            // disconnectBothBlock('m7/2]_CM1K5Wk7+p5og:', {x: -6, y: -6})
            // connectBothBlock('m7/2]_CM1K5Wk7+p5og:', 'O4CtD1Z*RK+^ikI-*y:u')
            // connectBothBlock('Q9:51[,(,oeGvT%DefNy', 'oc2h?q/hs?:Q95W@FV!R', 'SUBSTACK')
          // }, 3000);

          // setTimeout(() => {
          //   // 删除正移动中的评论
          //   deleteComment("]}R[zHj[suu]J70Q3`u-")
          // }, 3000);

          // setTimeout(() => {
          //   // 移动正移动中的评论
          //   moveComment("]}R[zHj[suu]J70Q3`u-", 722, 653)
          // }, 3000);

          // setTimeout(() => {
            // 更新正移动中的评论
            // 有问题，已处理
            // updateComment("]}R[zHj[suu]J70Q3`u-", {minimized: true})
            // updateComment("]}R[zHj[suu]J70Q3`u-", {text: "啊阿斯蒂芬神鼎飞丹砂sdfsakljdskfjkljsdklfjkljklsdjfkljakljklsjdfkljklsdjklfjlkjlk"})
            // 有问题,已处理
            // updateComment("]}R[zHj[suu]J70Q3`u-", {width: 266.6666259765625, height: 342})
          // }, 3000);

          // setTimeout(() => {
          //   createFrame({
          //     "id": "bp(`IZ!MbJO09|XDq[iG",
          //     "title": "代码框",
          //     "color": "45, 140, 255",
          //     "locked": false,
          //     "collapsed": false,
          //     "blocks": ['Ppl}Zvo@`t9W^OUK/IbI', '4SAJW)IzsC7|WnWnx~UL'],
          //     "width": 762,
          //     "height": 519,
          //     "x": 174.8,
          //     "y": 374.8
          //   })
          // }, 3000);

          // setTimeout(() => {
          //   deleteFrame("~Pmq]C?8u0fO3`8ToXDP")
          // }, 3000);

          // 测试移动正在被Frame拖着移动的Block
          // setTimeout(() => {
          //   updateFrame("~Pmq]C?8u0fO3`8ToXDP", {blocks: ['4SAJW)IzsC7|WnWnx~UL']})
          //   moveBlockTo("Ppl}Zvo@`t9W^OUK/IbI", {x: 536, y: 539});
          // }, 3000)

          // 测试移动正在被Frame拖着移动的Block
          // setTimeout(() => {
          //   updateFrame("~Pmq]C?8u0fO3`8ToXDP", {color: '255, 199, 0'})
          // }, 3000)

          // 如果一个Frame被锁定了，但他被别人在拖动，等别人拖动结束后该如何处理
          // setTimeout(() => {
          //   updateFrame("~Pmq]C?8u0fO3`8ToXDP", {color: '255, 199, 0'})
          //   updateFrame("~Pmq]C?8u0fO3`8ToXDP", {collapsed: true})
          //   updateFrame("~Pmq]C?8u0fO3`8ToXDP", {locked: true})
          //   setTimeout(() => {
          //     updateFrame("~Pmq]C?8u0fO3`8ToXDP", {collapsed: false})
          //   }, 1000);
          // }, 3000)

          // 连接积木 stack + stack
          // setTimeout(() => {
          //   moveBlockTo("ILLo|?c|fuz*I|-zE=;M", {x: 446, y: 437});
          //   connectBothBlock("*D?Cy7pOv{hZD4QR-{--", "ILLo|?c|fuz*I|-zE=;M");
          // }, 3000)

          // 连接积木 input + stack
          // setTimeout(() => {
          //   connectBothBlock("*D?Cy7pOv{hZD4QR-{--", "AmBgpdKG@V$_vsO=.?P$", "SUBSTACK");
          // }, 3000)

          // 连接积木 input + stack
          // setTimeout(() => {
          //   connectBothBlock("*D?Cy7pOv{hZD4QR-{--", "AmBgpdKG@V$_vsO=.?P$", "SUBSTACK");
          // }, 3000)

          // 测试删除拖动中的积木(1 row) 删除头
          // setTimeout(() => {
          //   disconnectBothBlock(".ROZy2^d%1.?Lwm::Uww", {x: 651, y: 935});
          //   deleteBlock("@;uQ;H1}I}c=uX-UeACk")
          // }, 3000)

          // 测试删除拖动中的所有（2 row）积木
          // setTimeout(() => {
          //   // 拖拽到左侧进行删除
          //   moveBlockTo("@;uQ;H1}I}c=uX-UeACk", {x: -193, y: 562});
          //   deleteBlock(".ROZy2^d%1.?Lwm::Uww")
          //   deleteBlock("@;uQ;H1}I}c=uX-UeACk")
          // }, 3000)

          // 测试删除拖动中的所有（3 row）积木
          // setTimeout(() => {
          //   // 拖拽到左侧进行删除
          //   moveBlockTo("5Bql7e2~5)7zvBe:+rAa", {x: -193, y: 562});
          //   deleteBlock(",by]S!}P}mY46)]bY7M9")
          //   deleteBlock("Cj[XUWh^,bH$Tv-YDKZE")
          //   deleteBlock(",EGK5eUDHmhmz8Ef|k4D")
          //   deleteBlock("5Bql7e2~5)7zvBe:+rAa")
          // }, 3000)

          // 删除尾部 (1 row)
          // setTimeout(() => {
          //   disconnectBothBlock(".ROZy2^d%1.?Lwm::Uww", {x: 397, y: 384});
          //   deleteBlock(".ROZy2^d%1.?Lwm::Uww")
          // }, 3000)

          // setTimeout(() => {
            // disconnectBothBlock("Cj[XUWh^,bH$Tv-YDKZE", {x: 651, y: 935});
            // deleteBlock(",by]S!}P}mY46)]bY7M9")
            // deleteBlock("Cj[XUWh^,bH$Tv-YDKZE")
          // }, 3000)

          // 删除中间
          // setTimeout(() => {
          //   disconnectBothBlock("Cj[XUWh^,bH$Tv-YDKZE", {x: 751, y: 681});
          //   connectBothBlock(",by]S!}P}mY46)]bY7M9", ",EGK5eUDHmhmz8Ef|k4D");
          //   deleteBlock("Cj[XUWh^,bH$Tv-YDKZE")
          //   deleteBlock(",EGK5eUDHmhmz8Ef|k4D")
          // }, 3000)

          // 更新变量名
          // setTimeout(() => {
          //   setTimeout(() => {updateVariableName("n)0Jvi!$+N1AsiU~I=hN", "var")}, 3000);
          // }, 3000)

          // setTimeout(() => {
          //   disconnectBothBlock("Gb`=u!Y^e|pZ;29_p(eH");
          //   connectBothBlock("LD-5Lll;,];[hNCOM{0e", "INFnJV!}n(o2S!5UJ`f/", "SUBSTACK");
          // }, 3000)
        }

        const draggingBlockBlocks = new Set();
        const draggingFrames = new Set();

        let draggingTargetName = null;

        const startBlockDrag = Blockly.BlockDragger.prototype.startBlockDrag;
        const endBlockDrag = Blockly.BlockDragger.prototype.endBlockDrag;
        const startFrameDrag = Blockly.FrameDragger.prototype.startFrameDrag;
        const endFrameDrag = Blockly.FrameDragger.prototype.endFrameDrag;
        
        Blockly.BlockDragger.prototype.startBlockDrag = function (...arg) {
            startBlockDrag.call(this, ...arg);
            initDraggingBlockBlocks(this.draggingBlock_);
            draggingTargetName = "BLOCK"
        };

        Blockly.FrameDragger.prototype.startFrameDrag = function (...arg) {
          startFrameDrag.call(this, ...arg);
          draggingTargetName = "FRAME"
          draggingFrames.add(this.draggingFrame_.id)
          Object.values(this.draggingFrame_.blockDB_).forEach((block) => {
            initDraggingBlockBlocks(block);
          });
        };

        Blockly.BlockDragger.prototype.endBlockDrag = function (...arg) {
            endBlockDrag.call(this, ...arg);
            draggingBlockBlocks.clear();
        };

        Blockly.FrameDragger.prototype.endFrameDrag = function (...arg) {
            endFrameDrag.call(this, ...arg);
            draggingBlockBlocks.clear();
        };

        const performCallbackWithoutEvent = (callback) => {
          Blockly.Events.disable();
          callback();
          Blockly.Events.enable();
        };

        function initDraggingBlockBlocks (blockSvg) {
          const recurseThrough = block => {
              draggingBlockBlocks.add(block.id);
              // Recurse through all blocks attached under this one.
              for (let i = 0; i < block.childBlocks_.length; i++) {
                  recurseThrough(block.childBlocks_[i]);
              }
          };
          recurseThrough(blockSvg);
        }

        function performAction(blocks, callback) {
          const isDragging = blocks.some((block) => draggingBlockBlocks.has(block.id));
          if (isDragging) {
            console.log('draggingTargetName', draggingTargetName);
            if (draggingTargetName === 'BLOCK') {
              const _endBlockDrag = Blockly.BlockDragger.prototype.endBlockDrag;
              Blockly.BlockDragger.prototype.endBlockDrag = function (e, currentDragDeltaXY, checkDraggingBlockAndDraggedConnection) {
                _endBlockDrag.call(this, e, currentDragDeltaXY, () => {
                  performCallbackWithoutEvent(callback.bind(this, this));
                  if (checkDraggingBlockAndDraggedConnection) {
                    checkDraggingBlockAndDraggedConnection(this);
                  }
                  Blockly.BlockDragger.prototype.endBlockDrag = _endBlockDrag;
                });
              };
            } else if (draggingTargetName === 'FRAME') {
              const _endFrameDrag = Blockly.FrameDragger.prototype.endFrameDrag;
              Blockly.FrameDragger.prototype.endFrameDrag = function (e, currentDragDeltaXY, checkDraggingBlockAndDraggedConnection) {
                _endFrameDrag.call(this, e, currentDragDeltaXY, () => {
                  performCallbackWithoutEvent(callback.bind(this, this));
                  if (checkDraggingBlockAndDraggedConnection) {
                    checkDraggingBlockAndDraggedConnection(this);
                  }
                  Blockly.BlockDragger.prototype.endFrameDrag = _endFrameDrag;
                });
              };
            }
          } else {
            performCallbackWithoutEvent(callback);
          }
        }

        function performCommentAction(comment, callback) {
          if (workspace.currentGesture_ && workspace.currentGesture_.bubbleDragger_) {
            if (workspace.currentGesture_.bubbleDragger_.draggingBubble_ === comment.bubble_) {
              const _endBubbleDrag = Blockly.BubbleDragger.prototype.endBubbleDrag;
              Blockly.BubbleDragger.prototype.endBubbleDrag = function (...args) {
                _endBubbleDrag.call(this, ...args);
                performCallbackWithoutEvent(callback.bind(this, this));
                Blockly.BlockDragger.prototype.endBubbleDrag = _endBubbleDrag;
              };
            }
          } else {
            performCallbackWithoutEvent(callback);
          }
        }

        function performFrameAction(frame, callback) {
          if (draggingFrames.has(frame.id)) {
            const _endFrameDrag = Blockly.FrameDragger.prototype.endFrameDrag;
            Blockly.FrameDragger.prototype.endFrameDrag = function (e, currentDragDeltaXY, checkDraggingBlockAndDraggedConnection) {
              _endFrameDrag.call(this, e, currentDragDeltaXY, () => {
                performCallbackWithoutEvent(callback.bind(this, this));
                if (checkDraggingBlockAndDraggedConnection) {
                  checkDraggingBlockAndDraggedConnection(this);
                }
                Blockly.BlockDragger.prototype.endFrameDrag = _endFrameDrag;
              });
            };
          } else {
            performCallbackWithoutEvent(callback);
          }
        }

        // 将积木与其 parent 断开连接
        function disconnectBothBlock(blockId, coordinate) {
          const oldBlock = workspace.getBlockById(blockId);
          if (oldBlock) {
            performAction([oldBlock], (blockDragger) => {
              const block = workspace.getBlockById(blockId);
              const parent = block.getParent()
              console.trace('Debug disconnectBothBlock', blockId);
              if (block) {
                if (blockDragger) {
                  const connection = block.outputConnection || block.previousConnection;
                  if (connection.isConnected()) {
                    blockDragger.draggedConnectionManager_.reserveLocalConnection.push(connection);
                  }
                }
                performCallbackWithoutEvent(() => {
                  block.unplug();
                  if (coordinate) {
                    const xy = block.getRelativeToSurfaceXY();
                    const rtlAwareX = workspace.RTL ? workspace.getWidth() - coordinate.x : coordinate.x;
                    block.moveBy(rtlAwareX - xy.x, coordinate.y - xy.y, false);
                  }
                })
              }
            });
          }
        }

        // 将积木与其 parent 连接上
        function connectBothBlock(blockId, parentId, inputName) {
          const oldBlock = workspace.getBlockById(blockId);
          const oldParentBlock = workspace.getBlockById(parentId);
          if (oldBlock && oldParentBlock) {
            const oldParent = oldBlock.getParent();
            performAction([oldBlock, oldParentBlock],
              (blockDragger) => {
                console.log('Debug connectBothBlock', blockId, parentId);
                const block = workspace.getBlockById(blockId);
                const parentBlock = workspace.getBlockById(parentId);
                if (block && parentBlock) {
                  const blockConnection =
                    block.outputConnection || block.previousConnection;
                  let parentConnection;
                  if (inputName) {
                    const input = parentBlock.getInput(inputName);
                    if (input) {
                      parentConnection = input.connection;
                    }
                  } else if (blockConnection.type === 4) {
                    parentConnection = parentBlock.nextConnection;
                  }
                  if (parentConnection) {
                    blockConnection.connect(parentConnection);
                    if (blockDragger) {
                      const {draggedConnectionManager_: {closestConnection_, localConnection_}, draggingBlock_} = blockDragger;
                      // 修正本地数据
                      if (closestConnection_) {
                        // 避免成环
                        console.log('避免成环');
                        if (closestConnection_.sourceBlock_.getSvgRoot().contains(draggingBlock_.getSvgRoot()) ||
                          draggingBlock_.getSvgRoot().contains(closestConnection_.sourceBlock_.getSvgRoot())
                        ) {
                          blockDragger.draggedConnectionManager_.update({x: 1e6, y: 1e6}, blockDragger.deleteArea_, blockDragger.wasOutside_);
                        }
                        // 避免出现 1 -> 2 -> 3 在 1 后插入 A -> B 后，形成 1 -> A -> 2 -> 3 -> B, 正确的应该是 1 -> A -> B -> 2 -> 3
                        if (localConnection_ === parentConnection) {
                          let nextConnection = block.nextConnection;
                          // 使用最后面的积木链接后续的积木
                          while (nextConnection.targetConnection) {
                            nextConnection = nextConnection.targetConnection.sourceBlock_.nextConnection;
                          }
                          blockDragger.draggedConnectionManager_.localConnection_ = nextConnection;
                        }
                      }
                    }
                  } else {
                    log.warn(`Can't connect to non-existent input: ${inputName}`);
                  }
                }
              }
            );
          }
        }

        // 移动积木
        function moveBlockTo(blockId, {x, y}) {
          const beforeBlock = workspace.getBlockById(blockId);
          // If a block is already attached to another block, it is not moved,
          // if a block is being dragged, its coordinates, and parent may change when it is released, so the previous coordinates are not applied.
          performAction([beforeBlock], () => {
              console.log('Debug moveBlockTo', blockId, {x, y});
              const block = workspace.getBlockById(blockId);
              if (block && !block.getParent()) {
                  const xy = block.getRelativeToSurfaceXY();
                  const rtlAwareX = workspace.RTL ? workspace.getWidth() - x : x;
                  performCallbackWithoutEvent(() => {
                    console.log('Debug moveBlockTo', rtlAwareX - xy.x, y - xy.y);
                      block.moveBy(rtlAwareX - xy.x, y - xy.y, false);
                  });
              }
          });
        }

        // 新增积木
        function addBlocksToWorkspace(blocks) {
          const blocksState = DebugVM.deserializeBlocks(blocks);
          const scripts = Object.keys(blocksState).filter(
            (i) => blocksState[i].topLevel
          );
          const xml = `<xml xmlns="http://www.w3.org/1999/xhtml">${scripts
            .map((i) =>
              DebugVM.editingTarget.blocks.blockToXML(i, {}, blocksState)
            )
            .join()}</xml>`;
          Blockly.Xml.domToWorkspace(
            Blockly.Xml.textToDom(xml),
            Blockly.getMainWorkspace()
          );
        }

        // 删除积木
        function deleteBlock(blockId) {
          const currentBlock = workspace.getBlockById(blockId);
          if (currentBlock) {
            performAction([currentBlock], (blockDragger) => {
              const block = workspace.getBlockById(blockId);
              if (block) {
                if (blockDragger) {
                  const {localConnection_, reserveLocalConnection} = blockDragger.draggedConnectionManager_;
                  if (localConnection_ && block === localConnection_.sourceBlock_) {
                    if (block.previousConnection === localConnection_) {
                      const nextBlock = block.getNextBlock();
                      if (nextBlock) {
                        blockDragger.draggedConnectionManager_.localConnection_ = nextBlock.previousConnection;
                      } else if (reserveLocalConnection.length > 0) {
                        const conn = reserveLocalConnection.pop();
                        blockDragger.draggingBlock_ = conn.sourceBlock_;
                        blockDragger.draggedConnectionManager_.localConnection_ = conn;
                      } else {
                        // 删完了，没有可连的了
                        performCallbackWithoutEvent(() => {
                          blockDragger.draggedConnectionManager_.hidePreview_();
                        })
                        blockDragger.draggedConnectionManager_.closestConnection_ = null;
                      }
                    }
                  }
                }
                const _dragger = workspace.currentGesture_?.blockDragger_;
                if (_dragger && _dragger.draggedConnectionManager_.closestConnection_?.sourceBlock_ === block) {
                  _dragger.draggedConnectionManager_.hidePreview_();
                  _dragger.draggedConnectionManager_.closestConnection_ = null;
                  _dragger.draggedConnectionManager_.localConnection_ = null;
                }
                block.dispose(true, true);
              }
            });
          } else {
            log.warn(`Block(${blockId}) not find`);
          }
        }

        // 更新input
        function updateBlockInput(blockId, name, value) {
          performAction([workspace.getBlockById(blockId)], () => {
            const block = workspace.getBlockById(blockId);
            if (block) {
              const field = block.getField(name);
              if (field) {
                field.setValue(value);
              }
            }
          });
        }

        // 更新变量名
        function updateVariableName(varId, name) {
          performAction(workspace.getAllBlocks(), (blockDragger) => {
            workspace.renameVariableById(varId, name);
            if (blockDragger) {
              requestAnimationFrame(() => workspace.refreshToolboxSelection_());
            }
          });
        }

        // 创建变量
        function createVariable(...arg) {
          workspace.createVariable(...arg);
        }

        // 删除变量
        function deleteVariable(...arg) {
          workspace.deleteVariableById(...arg);
        }

        function deleteComment (commentId) {
          const comment = workspace.getCommentById(commentId);
          if (comment) {
              performCallbackWithoutEvent(() => {
                if (workspace.currentGesture_ && workspace.currentGesture_.bubbleDragger_) {
                  if (workspace.currentGesture_.bubbleDragger_.draggingBubble_ === comment.bubble_) {
                    workspace.currentGesture_.dispose();
                  }
                }
                comment.dispose(false, false);
              });
          } else {
              // Only complain about root-level block.
              log.warn(`Can't delete non-existent comment: ${commentId}`);
          }
        }

        function moveComment (commentId, x, y) {
            const comment = workspace.getCommentById(commentId);
            if (!comment) {
              log.warn(`Can't change non-existent comment: ${commentId}`);
              return;
            }
            // 不更新一个正在被拖动的comment的x,y
            if (workspace.currentGesture_ && workspace.currentGesture_.bubbleDragger_) {
              if (workspace.currentGesture_.bubbleDragger_.draggingBubble_ === comment.bubble_) {
                return;
              }
            }
            performCallbackWithoutEvent(() => {
                if (comment.workspace.RTL) {
                    comment.moveTo(workspaceWidth_ - x, y);
                } else {
                    comment.moveTo(x, y);
                }
            });
        }

        function updateComment (commentId, contents) {
          const comment = workspace.getCommentById(commentId);
          if (!comment) {
              log.warn(`Can't change non-existent comment: ${commentId}`);
              return;
          }
          if (contents.hasOwnProperty(comment, 'minimized')) {
              performCommentAction(() => {
                const comment = workspace.getCommentById(commentId);
                if (comment) {
                  comment.setMinimized(contents.minimized);
                }
              return;
              });
          }
          if (contents.hasOwnProperty('width') && contents.hasOwnProperty('height')) {
              performCommentAction(comment, () => {
                const comment = workspace.getCommentById(commentId);
                if (comment) {
                  comment.setSize(contents.width, contents.height);
                }
              return;
              });
          }
          if (contents.hasOwnProperty('text')) {
            performCallbackWithoutEvent(() => {
              comment.setText(contents.text);
            });
          }
        }

        function createFrame (data) {
          performAction(data.blocks.map(i => workspace.getBlockById(i)).filter(Boolean), () => {
            const frame = workspace.createFrame(data);
            if (frame.getBlockIds().length !== data.blocks.length) {
              Blockly.Events.enable();
              frame.oldBlockIdList_ = data.blocks;
              frame.fireFrameBlocksChange();
              Blockly.Events.disable();
            }
            workspace.resizeContents();
          });
        }

        function deleteFrame (frameId) {
            performCallbackWithoutEvent(() => {
                workspace.deleteFrameById(frameId);
            });
        }

        function updateFrame (frameId, contents) {
            const frame = this.workspace.getFrameById(frameId);
            if (!frame) {
                log.warn(`Can't change non-existent frame: ${frameId}`);
                return;
            }
            performCallbackWithoutEvent(() => {
                if (contents.hasOwnProperty('blocks')) {
                  performFrameAction(frame, () => {
                    const l1 = contents.blocks;
                    const l2 = Object.keys(frame.blockDB_);
                    const addedBlocks = l1.filter(v => l2.indexOf(v) === -1);
                    addedBlocks.forEach(blockId => {
                        const block = workspace.getBlockById(blockId);
                        if (block) {
                            const result = block.requestMoveInFrame();
                            // If it fail to add the block to frame, it means that there is a special scenario present,
                            // such as the Block needing to change from a connected state to a disconnected state. In this case,
                            // the Block cannot be added because it is a non-top level block. It needs to be waited for
                            // the Block to move to the top level block and then tried again.
                            if (!result) {
                            // Here, a hack is used to make the Block try to add frames later on,
                            // the first frame it tries to add is this frame.
                                const temp = workspace.frameDB_[frameId];
                                delete workspace.frameDB_[frameId];
                                workspace.frameDB_[frameId] = temp;
                            }
                        }
                    });
                    const deletedBlocks = l2.filter(v => l1.indexOf(v) === -1);
                    deletedBlocks.forEach(blockId => {
                        const block = workspace.getBlockById(blockId);
                        if (block) {
                            block.requestMoveOutFrame();
                        }
                    });
                  })
                }
                if (contents.hasOwnProperty('rect')) {
                    frame.setBoundingClientRect(contents.rect, false);
                }
                if (contents.hasOwnProperty('color')) {
                    frame.setColor(contents.color);
                }
                if (contents.hasOwnProperty('collapsed')) {
                    frame.triggerChangeCollapsed(contents.collapsed);
                }
                if (contents.hasOwnProperty('locked')) {
                    frame.triggerChangeLock();
                }
            });
        }
    </script>
  </body>
</html>
